from __future__ import annotations

import os
from typing import Dict


DEFAULT_LANGUAGE = "en"
_language = DEFAULT_LANGUAGE

_TRANSLATIONS: Dict[str, Dict[str, str]] = {
    "fr": {
        "error_value_required": "Veuillez saisir une valeur.",
        "error_empty_choice_list": "La liste de choix est vide.",
        "error_invalid_choice": "Réponse invalide, veuillez choisir un index valide.",
        "prompt_keep_existing": "{message} (garder les valeurs existantes ?)",
        "prompt_multi_value_hint": "{message} (entrée vide pour terminer)",
        "prompt_yes_no_default_yes": "O/n",
        "prompt_yes_no_default_no": "o/N",
        "prompt_yes_no_invalid": "Merci de répondre par oui ou non.",
        "prompt_ruleset_name": "Nom du ruleset",
        "prompt_ruleset_target": "Cible du ruleset",
        "prompt_ruleset_enforcement": "Mode d'application",
        "prompt_include_targets": "Cibles {target} à inclure (laisser vide pour toutes)",
        "prompt_exclude_targets": "Cibles {target} à exclure",
        "prompt_apply_default_branch": "Appliquer le ruleset à la branche par défaut ?",
        "prompt_additional_targets": "Ajouter d'autres branches ou motifs en plus de la branche par défaut ?",
        "prompt_modify_bypass": "Souhaitez-vous modifier les bypass existants ?",
        "prompt_define_bypass": "Définir des acteurs autorisés à contourner le ruleset ?",
        "prompt_rules_actions": "Gestion des règles",
        "prompt_list_recent_checks": "Lister les checks récemment observés ?",
        "prompt_include_default_branch": "Inclure la branche par défaut ?",
        "prompt_include_latest_pr": "Inclure la PR ouverte ou récemment fusionnée la plus récente ?",
        "prompt_extra_pr_numbers": "Numéros de PR supplémentaires (séparés par des espaces) :",
        "prompt_extra_refs": "Références supplémentaires (branches ou SHAs, séparées par des espaces) :",
        "prompt_warning": "Avertissement: {message}",
        "prompt_inspected_refs": "Références analysées :",
        "prompt_no_checks_found": "Aucun check détecté pour les références sélectionnées.",
        "prompt_require_strict_checks": "Exiger que les PR soient testées avec le dernier commit (strict_required_status_checks_policy) ?",
        "prompt_allow_bypass_failing": "Autoriser la création de refs même si les checks ne passent pas (do_not_enforce_on_create) ?",
        "prompt_open_editor_error": "L'éditeur s'est terminé en erreur ({exc}).",
        "prompt_empty_editor_content": "Le contenu de l'éditeur est vide.",
        "prompt_invalid_json": "Le contenu fourni n'est pas un JSON valide. Supprimez ou corrigez les annotations.",
        "prompt_editor_not_found": "Aucun éditeur détecté (VISUAL/EDITOR, gh config get editor). Définissez-en un ou utilisez --file pour fournir un JSON.",
        "prompt_multi_value_prompt": "{message} (entrée vide pour terminer)",
        "prompt_add_rule": "Ajouter une règle",
        "prompt_edit_rule": "Modifier une règle",
        "prompt_delete_rule": "Supprimer une règle",
        "prompt_finish": "Terminer",
        "prompt_choice_invalid": "Choix invalide.",
        "prompt_select_rule_index": "Index de la règle à {action}:",
        "prompt_numeric_index_required": "Index numérique attendu.",
        "prompt_index_out_of_bounds": "Index hors limites.",
        "prompt_rule_removed": "Règle supprimée : {summary}",
        "prompt_modify_rule_editor": "Modification via éditeur JSON.",
        "prompt_configure_required_checks": "Configuration des checks requis.",
        "prompt_review_ruleset": "Ouvrir l'objet JSON final dans l'éditeur par défaut avant envoi.",
        "prompt_confirm_delete": "Supprimer le ruleset {ruleset_id} ? Cette action est irréversible.",
        "prompt_delete_cancelled": "Suppression annulée.",
        "prompt_ruleset_deleted": "Ruleset {ruleset_id} supprimé.",
        "prompt_ruleset_created": "Ruleset créé avec succès (ID {ruleset_id}).",
        "prompt_ruleset_updated": "Ruleset {ruleset_id} mis à jour.",
        "prompt_validation_errors": "Erreurs de validation OpenAPI détectées :",
        "prompt_continue_despite_errors": "Poursuivre {action} malgré tout ?",
        "prompt_action_cancelled": "{action} annulée.",
        "prompt_no_rules": "Ce ruleset ne contient aucune règle.",
        "prompt_rule_added": "Règle ajoutée.",
        "prompt_rule_types": "Type de règle à ajouter :",
        "prompt_required_checks_label": "Checks requis (required_status_checks)",
        "prompt_json_editor_label": "Éditeur JSON libre",
        "prompt_json_editor_header": "Modifiez le JSON de la règle.\n- La clé 'type' doit correspondre à un type de règle pris en charge (ex : required_status_checks).\n- La clé 'parameters' contient les options spécifiques à ce type.\n- Les lignes qui commencent par # ou // sont ignorées lors de l'enregistrement.",
        "prompt_manage_rules_heading": "Gestion des règles",
        "prompt_rules_menu_option_add": "1. Ajouter une règle",
        "prompt_rules_menu_option_edit": "2. Modifier une règle",
        "prompt_rules_menu_option_delete": "3. Supprimer une règle",
        "prompt_rules_menu_option_finish": "4. Terminer",
        "prompt_rules_menu_option_finish_only": "2. Terminer",
        "prompt_rules_menu_choice": "Votre choix:",
        "prompt_invalid_rule_type": "Type de règle inconnu.",
        "prompt_open_editor_header": "Modifiez l'objet JSON du ruleset avant envoi.",
        "prompt_ruleset_name_help": "Nom du ruleset",
        "prompt_ruleset_target_help": "Cible du ruleset",
        "prompt_ruleset_enforcement_help": "Mode d'application",
        "prompt_skip_validation": "Ne pas valider localement le payload via le schéma OpenAPI.",
        "prompt_select_language": "Langue",
        "arg_lang_help": "Langue de l'interface (défaut : anglais).",
        "arg_repo_help": "Dépôt cible (OWNER/REPO ou HOST/OWNER/REPO). Par défaut utilise le dépôt courant.",
        "command_list_help": "Lister les rulesets du dépôt.",
        "command_view_help": "Afficher un ruleset précis.",
        "command_delete_help": "Supprimer un ruleset.",
        "command_create_help": "Créer un nouveau ruleset.",
        "command_update_help": "Modifier un ruleset existant.",
        "command_rule_help": "Gérer les règles individuelles d'un ruleset.",
        "option_yes_help": "Confirmation automatique (non interactif).",
        "option_file_help": "Fichier JSON pré-rempli pour la création. Si omis, un assistant interactif est utilisé.",
        "option_from_existing_help": "Cloner un ruleset existant avant modifications interactives.",
        "option_editor_help": "Ouvrir l'objet JSON final dans l'éditeur par défaut avant envoi.",
        "option_skip_validate_help": "Ne pas valider localement le payload via le schéma OpenAPI.",
        "option_rule_skip_validate_help": "Ne pas valider localement les modifications de ruleset.",
        "command_rules_list_help": "Lister les règles d'un ruleset.",
        "command_rules_add_help": "Ajouter une règle à un ruleset.",
        "command_rules_edit_help": "Modifier une règle existante.",
        "command_rules_delete_help": "Supprimer une règle d'un ruleset.",
        "option_rules_delete_confirm_help": "Confirmation automatique (non interactif).",
        "command_checks_help": "Lister les checks (statuts/actions) récemment observés.",
        "option_checks_ref_help": "Référence (branche ou SHA) pour détecter les checks. Défaut : branche par défaut.",
        "option_checks_pr_help": "Numéro de pull request à inclure (répétable).",
        "option_checks_latest_pr_help": "Inclure automatiquement la PR ouverte la plus récente.",
        "option_checks_no_default_help": "Ne pas analyser le commit de la branche par défaut.",
        "error_editor_missing": "Aucun éditeur détecté (VISUAL/EDITOR, gh config get editor). Définissez-en un ou utilisez --file pour fournir un JSON.",
        "error_keyboard_interrupt": "\nInterruption par l'utilisateur (Ctrl+C).",
        "error_api": "Erreur : {message}",
        "error_runtime": "Erreur : {message}",
        "validation_errors_heading": "Erreurs de validation OpenAPI détectées :",
        "validation_continue": "Poursuivre {action} malgré tout ?",
        "validation_cancelled": "{action} annulée.",
        "list_no_rulesets": "Aucun ruleset dans ce dépôt.",
        "table_header_id": "ID",
        "table_header_name": "Nom",
        "table_header_target": "Cible",
        "table_header_enforcement": "Mode",
        "table_header_rules": "Règles",
        "table_header_updated": "Mis à jour",
        "action_creation": "la création",
        "action_update": "la mise à jour",
        "rule_list_empty": "Ce ruleset ne contient aucune règle.",
        "rule_list_entry": "[{index}] {summary}",
        "action_rule_add": "l'ajout de la règle",
        "rule_added": "Règle ajoutée. Le ruleset compte désormais {count} règles.",
        "error_rule_index": "Index de règle invalide.",
        "action_rule_update": "la mise à jour de la règle",
        "rule_updated": "Règle {index} mise à jour. ({summary})",
        "rule_delete_confirm": "Supprimer la règle [{index}] {summary} ?",
        "action_rule_delete": "la suppression de la règle",
        "rule_deleted": "Règle supprimée : {summary}",
        "warning_default_branch": "Branche par défaut : {error}",
        "warning_pr_specific": "PR #{number} : {error}",
        "warning_latest_open_pr": "PR la plus récente (ouverte) : {error}",
        "warning_latest_merged_pr": "PR la plus récente (fusionnée) : {error}",
        "warning_latest_pr_no_sha": "PR la plus récente : impossible de déterminer le SHA du head.",
        "warning_no_recent_pr": "Aucune PR ouverte ni fusionnée récemment trouvée.",
        "warning_prefix": "Avertissement : {message}",
        "checks_none_found": "Aucun check détecté parmi les références inspectées.",
        "checks_detected_heading": "Checks détectés :",
        "checks_entry": "- {label}  [sources : {origins}]",
        "checks_inspected_heading": "\nRéférences analysées :",
        "checks_reference_entry": "- {label}",
        "manage_rules_current": "\nRègles actuelles :",
        "manage_rules_none": "- (aucune)",
        "manage_rules_entry": "[{index}] {summary}",
        "manage_options_heading": "\nOptions :",
        "manage_option_add": "1. Ajouter une règle",
        "manage_option_edit": "2. Modifier une règle",
        "manage_option_delete": "3. Supprimer une règle",
        "manage_option_finish": "4. Terminer",
        "manage_option_finish_only": "2. Terminer",
        "manage_choice_prompt": "Votre choix:",
        "manage_invalid_choice": "Choix invalide.",
        "manage_select_action_edit": "modifier",
        "manage_select_action_delete": "supprimer",
        "add_rule_type_heading": "\nType de règle à ajouter :",
        "add_rule_option_required_checks": "1. Checks requis (required_status_checks)",
        "add_rule_option_json_editor": "2. Éditeur JSON libre",
        "add_rule_choice_prompt": "Votre choix [1]: ",
        "edit_required_checks_heading": "Modification d'une règle de checks requis.",
        "edit_rule_via_editor": "Modification via éditeur JSON.",
        "required_checks_heading": "\nConfiguration des checks requis.",
        "required_checks_prompt_recent": "Lister les checks récemment observés ?",
        "required_checks_include_default": "Inclure la branche par défaut ?",
        "required_checks_include_latest_pr": "Inclure la PR ouverte ou récemment fusionnée la plus récente ?",
        "required_checks_extra_prs": "Numéros de PR supplémentaires (séparés par des espaces) : ",
        "required_checks_invalid_pr": "Numéro de PR ignoré (non numérique) : {token}",
        "required_checks_extra_refs": "Références supplémentaires (branches ou SHAs, séparées par des espaces) : ",
        "required_checks_none": "Aucun check détecté pour les références sélectionnées.",
        "required_checks_strict": "Exiger que les PR soient testées avec le dernier commit (strict_required_status_checks_policy) ?",
        "required_checks_allow_create": "Autoriser la création de refs même si les checks ne passent pas (do_not_enforce_on_create) ?",
        "status_checks_current_heading": "\nChecks actuellement requis :",
        "status_checks_none": "- (aucun)",
        "status_checks_recent_heading": "\nChecks récemment observés :",
        "status_checks_options_heading": "\nOptions :",
        "status_checks_option_add": "1. Ajouter un check",
        "status_checks_option_remove": "2. Retirer un check",
        "status_checks_option_finish": "3. Terminer",
        "status_checks_option_finish_only": "2. Terminer",
        "status_checks_choice_prompt": "Votre choix:",
        "status_checks_context_prompt": "Nom du check (ou numéro de la liste ci-dessus): ",
        "status_checks_invalid_index": "Index invalide.",
        "status_checks_name_required": "Nom obligatoire.",
        "status_checks_integration_suffix": " (laisser vide pour utiliser {value})",
        "status_checks_integration_prompt": "Integration ID{suffix}: ",
        "status_checks_integration_numeric": "Integration ID doit être numérique.",
        "status_checks_select_remove": "retirer",
        "status_checks_removed": "Check retiré : {context}",
        "bypass_heading": "\nActeurs pouvant contourner le ruleset :",
        "bypass_option_add": "1. Ajouter",
        "bypass_option_remove": "2. Supprimer",
        "bypass_option_finish": "3. Terminer",
        "bypass_option_finish_only": "2. Terminer",
        "bypass_removed": "Acteur retiré : {summary}",
        "bypass_actor_type_heading": "\nType d'acteur :",
        "bypass_actor_option_repo": "1. RepositoryRole (ex: admin, maintain)",
        "bypass_actor_option_team": "2. Team (ORG/slug)",
        "bypass_actor_option_integration": "3. Integration (ID numérique)",
        "bypass_actor_option_org_admin": "4. OrganizationAdmin",
        "bypass_actor_option_enterprise_admin": "5. EnterpriseAdmin",
        "bypass_mode_prompt": "Mode de contournement",
        "bypass_role_prompt": "Nom du rôle du dépôt (ex: maintain): ",
        "bypass_role_empty": "Le rôle ne peut pas être vide.",
        "bypass_team_prompt": "Team (ORG/slug): ",
        "bypass_team_format": "Format attendu : ORG/slug.",
        "bypass_integration_prompt": "Integration ID: ",
        "bypass_team_lookup_failed": "Impossible de récupérer l'identifiant de l'équipe.",
        "ruleset_details_id": "ID : {value}",
        "ruleset_details_name": "Nom : {value}",
        "ruleset_details_target": "Cible : {value}",
        "ruleset_details_enforcement": "Mode : {value}",
        "ruleset_details_created": "Créé : {value}",
        "ruleset_details_updated": "Mis à jour : {value}",
        "ruleset_details_conditions": "Conditions :",
        "ruleset_details_condition_entry": "  - {key}: {value}",
        "ruleset_details_bypass": "Acteurs pouvant contourner :",
        "ruleset_details_bypass_entry": "  - {summary}",
        "ruleset_details_rules": "Règles :",
        "ruleset_details_rule_entry": "  [{index}] {summary}",
        "subprocess_error": "Commande {command} en erreur : {stderr}",
        "select_rule_prompt": "Index de la règle à {action}: ",
        "select_rule_numeric": "Index numérique attendu.",
        "select_rule_out_of_range": "Index hors limites.",
        "error_rule_payload_type": "Une règle doit être un objet JSON avec la clé 'type'.",
        "cli_description": "Gérer les rulesets d'un dépôt GitHub.",
        "arg_ruleset_id": "Identifiant numérique du ruleset.",
        "option_json_output": "Sortie JSON brute.",
        "arg_rule_index": "Index (basé sur 1) de la règle.",
    }
}


def available_languages() -> Dict[str, str]:
    return {"en": "English", "fr": "Français"}


def set_language(lang: str | None) -> None:
    global _language
    if not lang:
        _language = DEFAULT_LANGUAGE
        return
    normalized = lang.lower()
    if normalized in ("en", "fr"):
        _language = normalized
    else:
        _language = DEFAULT_LANGUAGE


def get_language() -> str:
    return _language


def language_from_env() -> str | None:
    env = os.environ.get("GH_RULESET_EXT_LANG") or os.environ.get("LANG")
    if not env:
        return None
    return env.split(".")[0].lower()[0:2]


def translate(key: str, default: str, **kwargs) -> str:
    if _language == DEFAULT_LANGUAGE:
        return default.format(**kwargs)
    translations = _TRANSLATIONS.get(_language, {})
    text = translations.get(key, default)
    return text.format(**kwargs)
